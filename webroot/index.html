<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>the IOTA tangle</title>
  <link rel="stylesheet" href="main.css">
  <script src="lib/vivagraph.js"></script>
  <script src="main.js"></script>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
    integrity="sha256-k2WSCIexGzOj3Euiig+TlR8gA0EmPjuc79OEeY5L45g=" crossorigin="anonymous"></script>


  <meta name="application-name" content="The IOTA TAngle" />
  <meta name="theme-color" content="#ffffff">

  <meta property="og:image" content="http://tangle.glumb.de/image.png" />

  <meta name="description" content="See the IOTA Tangle in action.">
</head>

<body>
  <div class="graph" id="graph"></div>

  <script type="application/javascript">
    const tg = TangleGlumb(document.getElementById('graph'), {
      CIRCLE_SIZE: 60,
      PIN_OLD_NODES: false,
      STATIC_FRONT: false
    })

    const NUMBER_NODES = 4000
    const TANGLE_WIDTH = 60
    const TPS = 100

    const mockTxGenerator = (numberOfTx, tangleWidth, tps) => {

      let hashRb = [],
        rbPointer = 0;

      for (let i = 0; i < TANGLE_WIDTH; i++) {
        hashRb.push(Math.random() * 1000);
      }

      let hash = 1000

      function createTX() {
        const tx = {
          hash: hash + '',
          address: "$addr$",
          value: Math.floor(Math.random() * 10),
          timestamp: Date.now(),
          bundle_hash: "$bundle_hash$" + Math.floor(hash / 30),
          transaction_branch: hashRb[Math.floor(Math.random() * TANGLE_WIDTH)] + '',
          transaction_trunk: hashRb[Math.floor(Math.random() * TANGLE_WIDTH)] + '',
          // milestone: (hash == 1999),
          milestone: (Math.random() > 0.98),
          tag: "$tag$",
        }
        if (Math.random() < 0.2) {
          tx.transaction_branch = (hash - 1000 * Math.random()) + ''
        }
        rbPointer = ++rbPointer %
          TANGLE_WIDTH;
        hashRb[rbPointer] = tx.hash;

        hash++

        return tx
      }

      // setInterval(() => {
      //   tg.updateTx([createTX()])
      // }, SEND_INTERVAL);

      let txs = []
      for (let i = 0; i < NUMBER_NODES; i++) {
        txs.push(createTX())
      }

      function unrollTx(cb, resolve) {
        if (txs.length == 0) {
          resolve()
          return
        }
        for (let i = 0; i < tps / 10 && txs.length > 0; i++) {
          cb(txs.shift())
        }
        setTimeout(() => unrollTx(cb, resolve), 1000 / (tps / 10))
      }

      return {
        start: (cb) => {
          const p = new Promise((resolve, rej) => {
            unrollTx(cb, resolve)
          })
          return p
        }
      }
    }

    mockTxGenerator(NUMBER_NODES, TANGLE_WIDTH, TPS).start((tx) => {
      tg.updateTx([tx])
    }).then(() => console.log('done'))

    // tg.removeTx()
  </script>

</body>

</html>